("module-metadata" => ("icon" => "math") "access-key" => "8973" "PI" => 3.141599 "rules" => ("rule1" => ("Sum without arguments" (+) true 0) "rule2" => ("Product without arguments" (*) true 1) "rule3" => ("Redundant parenthesis" (x?) true x?) "rule4" => ("Redundant sum operator" (+ x?) true x?) "rule5" => ("Redundant product operator" (* x?) true x?) "rule6" => ("Redundant negative operator" (- (- x?)) true x?) "rule7" => ("Join sum operators" (+ a... (+ b...) c...) true (+ a... b... c...)) "rule8" => ("Join product operators" (* a... (* b...) c...) true (* a... b... c...)) "rule9" => ("Multiply numbers" (* a... x? b... y? c...) (if (and (= (type-of x?) "number") (= (type-of y?) "number")) (do (set match_map$/res (* x? y?)) true) false) (* res a... b... c...)) "rule10" => ("Sum numbers" (+ a... x? b... y? c...) (if (and (= (type-of x?) "number") (= (type-of y?) "number")) (do (set match_map$/res (+ x? y?)) true) false) (+ res a... b... c...)) "rule11" => ("Subtract numbers" (- a? b?) (if (and (= (type-of a?) "number") (= (type-of b?) "number")) (do (set match_map$/res (- a? b?)) true) false) res) "rule12" => ("Divide numbers" (/ a? b?) (if (and (= (type-of a?) "number") (= (type-of b?) "number")) (do (set match_map$/res (/ a? b?)) true) false) res) "rule13" => ("Negate number" (- x?) (if (= (type-of x?) "number") (do (set match_map$/res (- x?)) true) false) res) "rule14" => ("Replace negate operator by product by -1" (- a?) true (* -1 a?)) "rule15" => ("Divide element by itself" (/ x? x?) true 1) "rule16" => ("Sum element twice" (+ a... x? b... x? c...) true (+ a... b... c... (* 2 x?))) "rule17" => ("Multiply element by itself" (* a... x? b... x? c...) true (* a... b... c... (pow x? 2))) "rule18" => ("Multiply sum terms (left)" (* a... x? (+ y? b...) c...) (do (set match_map$/x2 (clone x? true)) true) (* a... (+ (* x? y?) (* x2 (+ b...))) c...)) "rule19" => ("Multiply sum terms (right)" (* a... (+ y? b...) x? c...) (do (set match_map$/x2 (clone x? true)) true) (* a... (+ (* x? y?) (* x2 (+ b...))) c...)) "rule20" => ("Common factor" (+ a... (* k1? x?) b... (* k2? x?) c...) (and (= (type-of k1?) "number") (= (type-of k2?) "number")) (+ a... b... c... (* (+ k1? k2?) x?))) "rule21" => ("Common factor (left)" (+ a... x? b... (* k? x?) c...) (and (= (type-of k?) "number")) (+ a... b... c... (* (+ k? 1) x?))) "rule22" => ("Common factor (right)" (+ a... (* k? x?) b... x? c...) (and (= (type-of k?) "number")) (+ a... (* (+ k? 1) x?) b... c...)) "rule23" => ("Multiple by zero" (* a... 0 b...) true 0) "rule24" => ("Sum zero" (+ a... 0 b...) (> (+ (size a...) (size b...)) 0) (+ a... b...)) "rule25" => ("Multiply by one" (* a... 1 b...) (> (+ (size a...) (size b...)) 0) (* a... b...)) "rule26" => ("Put number behind expression in sum" (+ a... x? y? b...) (and (= (type-of x?) "number") (!= (type-of y?) "number")) (+ a... y? x? b...)) "rule27" => ("Put number in front of expression in multiply" (* a... x? y? b...) (and (!= (type-of x?) "number") (= (type-of y?) "number")) (* a... y? x? b...)) "rule28" => ("Sort variables lexicografically" (fn? a... x? y? b...) (and (or (= fn? +) (= fn? *)) (= (type-of x?) "reference") (= (type-of y?) "reference") (> (string x?) (string y?))) (fn? a... y? x? b...)) "rule29" => ("Sort terms by power (1 power)" (+ a... (* f... x?) b... (* g... (pow x? k?)) c...) (and (= (type-of k?) "number") (> k? 1)) (+ a... (* g... (pow x? k?)) b... (* f... x?) c...)) "rule30" => ("Sort terms by power (2 powers with factors)" (+ a... (* f... (pow x? k1?)) b... (* g... (pow x? k2?)) c...) (and (= (type-of k1?) "number") (= (type-of k2?) "number") (> k2? k1?)) (+ a... (* g... (pow x? k2?)) b... (* f... (pow x? k1?)) c...)) "rule31" => ("Sort terms by power (2 powers without factors)" (+ a... (pow x? k1?) b... (pow x? k2?) c...) (and (= (type-of k1?) "number") (= (type-of k2?) "number") (> k2? k1?)) (+ a... (pow x? k2?) b... (pow x? k1?) c...)) "rule32" => ("Sort terms by power (2 powers with 1 factor left)" (+ a... (pow x? k1?) b... (* f... (pow x? k2?)) c...) (and (= (type-of k1?) "number") (= (type-of k2?) "number") (> k2? k1?)) (+ a... (* f... (pow x? k2?)) b... (pow x? k1?) c...)) "rule33" => ("Sort terms by power (2 powers with 1 factor right)" (+ a... (* f... (pow x? k1?)) b... (pow x? k2?) c...) (and (= (type-of k1?) "number") (= (type-of k2?) "number") (> k2? k1?)) (+ a... (pow x? k2?) b... (* f... (pow x? k1?)) c...)) "rule34" => ("Nested power" (pow (pow x? y?) z?) true (pow x? (* y? z?))) "rule35" => ("Increment power (left)" (* a... x? b... (pow x? y?) c...) true (* a... b... (pow x? (+ y? 1)) c...)) "rule36" => ("Increment power (right)" (* a... (pow x? y?) b... x? c...) true (* a... b... (pow x? (+ y? 1)) c...)) "rule37" => ("Sum powers" (* a... (pow x? y?) b... (pow x? z?) c...) true (* a... b... (pow x? (+ y? z?)) c...)) "rule38" => ("Power two numbers" (pow x? y?) (if (and (= (type-of x?) "number") (= (type-of y?) "number")) (do (set match_map$/res (pow x? y?)) true) false) res) "rule39" => ("Square root of power" (sqrt (pow x? 2)) true x?) "rule40" => ("Power of square root" (pow (sqrt x?) 2) true x?) "rule41" => ("Replace division by number by factor" (/ x? k?) (= (type-of k?) "number") (* (/ 1 k?) x?)) "rule42" => ("sin(x)/cos(x) is tan(x)" (/ (sin x?) (cos x?)) true (tan x?)) "rule43" => ("Remove negative operator in division by number" (/ (- x?) a?) (= (type-of a?) "number") (/ x? (- a?))) "rule44" => ("Replace subtract by sum" (- a? b?) true (+ a? (* -1 b?))) "rule45" => ("Common divisor" (/ (+ a? b?) c?) true (+ (/ a? c?) (/ b? c?))) "rule46" => ("rule36" (solve x? x? b?) (not (match (list b?) (list (quote a...) x? (quote b...)))) (solved x? b?)) "rule47" => ("rule37" (solve x? (+ a... x? b...) c?) (and (not (match a... (list (quote c...) x? (quote d...)))) (not (match b... (list (quote c...) x? (quote d...)))) (not (match (list c?) (list (quote c...) x? (quote d...))))) (solve x? x? (- c? (+ a... b...)))) "rule48" => ("rule38" (solve x? (* a... x? b...) c?) (and (not (match a... (list (quote c...) x? (quote d...)))) (not (match b... (list (quote c...) x? (quote d...)))) (not (match (list c?) (list (quote c...) x? (quote d...))))) (solve x? x? (/ c? (* a... b...)))) "rule49" => ("rule39" (solve x? (+ a... (* b... x? c...) d...) c?) (and (not (match a... (list (quote p...) x? (quote q...)))) (not (match b... (list (quote p...) x? (quote q...)))) (not (match c... (list (quote p...) x? (quote q...)))) (not (match d... (list (quote p...) x? (quote q...)))) (not (match (list c?) (list (quote p...) x? (quote q...))))) (solved x? (/ (- c? (+ a... d...)) (* b... c...)))) "rule50" => ("rule40" (solve x? a? b?) (match (list b?) (list (quote p...) x? (quote q...))) (solve x? (- a? b?) 0))) "apply-rule" => (function (expression rule) (local e result pattern condition replace-by subexpr) (set result null) (set e (list expression)) (set pattern rule/1) (set condition rule/2) (set replace-by rule/3) (match e pattern (if (eval condition (clone (local-scope))) (do (if (= match_parent$ null) false (do (set subexpr (merge replace-by match_map$)) (put match_parent$ match_position$ subexpr) (set result (first e)) true))) false)) result) "apply-rules" => (function (expression rules) (local temp temp2 reduced steps rule rule-idx) (set temp expression) (set reduced true) (set steps (list (clone expression true))) (while (and reduced (< (size steps) 100) (= (type-of temp) "list")) (set reduced false) (set rule-idx 0) (while (and (not reduced) (< rule-idx (size rules))) (set rule (get rules rule-idx)) (if (= rule/0 ###) (++ rule-idx) (do (set temp2 (apply-rule temp rule)) (if (= temp2 null) (++ rule-idx) (do (set temp temp2) (push steps rule/0) (push steps (clone temp2 true)) (set reduced true))))))) steps) "reduce" => (function (expr) (last (apply-rules expr rules))) "reducet" => (function (expr) (apply-rules expr rules)) "reduceq" => (function args (last (apply-rules args/0 rules))) "reduceqt" => (function args (apply-rules args/0 rules)) "renum_rules" => (function () (local i rule rule_name new_rules) (set new_rules (list)) (for (set i 0) (< i (size rules)) (++ i) (set rule (clone (get rules i) true)) (set rule_name (concat "rule" (+ i 1))) (put new_rules rule_name rule)) (set rules new_rules)))